//=============================================================================
//
// フェード処理 [fade.cpp]
// Author : 
//
//=============================================================================
#include "fade.h"
#include "texture.h"
#include "sprite.h"

//*****************************************************************************
// マクロ定義
//*****************************************************************************
#define	FADE_RATE					(0.02f)			// フェード係数


//*****************************************************************************
// プロトタイプ宣言
//*****************************************************************************


//*****************************************************************************
// グローバル変数
//*****************************************************************************
static int	g_TextureBgTitle;				// テクスチャ番号

FADE_STATE	g_FadeState = FADE_NONE;	// フェードの状態
int		g_SceneNext;				// 次のシーン
D3DXCOLOR	g_Color;					// フェードのカラー


//=============================================================================
// 初期化処理
//=============================================================================
HRESULT InitFade(void)
{
	//テクスチャ生成
	g_TextureBgTitle = LoadTexture((char*)"data/TEXTURE/fade_white.png");

	//初期化
	g_FadeState  = FADE_NONE;
	g_SceneNext = SCENE_NONE;
	g_Color = D3DXCOLOR(1.0, 1.0, 1.0, 1.0);

	return S_OK;
}

//=============================================================================
// 終了処理
//=============================================================================
void UninitFade(void)
{

}

//=============================================================================
// 更新処理
//=============================================================================
void UpdateFade(void)
{
	// フェード処理中
	if (g_FadeState != FADE_NONE)
	{
		if (g_FadeState == FADE_OUT)
		{// フェードアウト処理
			g_Color.a += FADE_RATE;		// α値を加算して画面を消していく

			if (g_Color.a >= 1.0f)
			{
				// フェードイン処理に切り替え
				g_Color.a = 1.0f;
				g_FadeState = FADE_IN;

				// モードを設定
				SetScene(g_SceneNext);
			}
		}
		else if (g_FadeState == FADE_IN)
		{// フェードイン処理
			g_Color.a -= FADE_RATE;		// α値を減算して画面を浮き上がらせる
			if (g_Color.a <= 0.0f)
			{
				// フェード処理終了
				g_Color.a = 0.0f;
				g_FadeState = FADE_NONE;
			}

		}
	}
}

//=============================================================================
// 描画処理
//=============================================================================
void DrawFade(void)
{
	// フェード処理をしていないのなら描画しない
	if (g_FadeState == FADE_NONE)
		return;	

	// １枚のポリゴンの頂点とテクスチャ座標を設定
	DrawSpriteColor(g_TextureBgTitle, SCREEN_WIDTH/2, SCREEN_HEIGHT/2, SCREEN_WIDTH, SCREEN_HEIGHT, 0.0f, 0.0f, 1.0f, 1.0f, g_Color);
}

/*------------------------------------------------------------------------------
   フェードアウト・フェードイン処理をしながらシーン遷移する関数
------------------------------------------------------------------------------*/
void SceneTransition(int nextScene)
{
	g_SceneNext = nextScene;
	g_FadeState = FADE_OUT;
}

/*------------------------------------------------------------------------------
   フェードイン処理をしながらシーンを開始する関数
------------------------------------------------------------------------------*/
void SceneFadeIn(SCENE nextScene)
{
	g_Color.a = 1.0f;
	g_FadeState = FADE_IN;
	SetScene(nextScene);
}

/*------------------------------------------------------------------------------
   フェード処理の状況を返す関数
------------------------------------------------------------------------------*/
FADE_STATE GetFadeState(void)
{
	return g_FadeState;
}

/*------------------------------------------------------------------------------
   フェードカラー設定する関数
------------------------------------------------------------------------------*/
void SetFadeColor(float r, float g, float b)
{
	g_Color = D3DXCOLOR(r, g, b, 1.0f);
}

